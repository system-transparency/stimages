#! /bin/bash
#
# Daemon signing ST OS images downloaded from GitLab CI/CD and upload
# them to an image server.
#
# Configuration is read from ~/.config/stsignd/config and ~/.config/stsignd/jobs/*.{conf,keys}
# State is written to files in ~/.local/state/stsignd/.
#

set -eu

# Download URL if the HTTP server reports it's newer than what LASTMOD_FILE says.
# Store downloaded file in FILE_OUT.
# Update LASTMOD_FILE if file is downloaded.
# "Return" http response code on stdout.
download() {
    local url="$1"; shift
    local file_out="$1"; shift
    local lastmod_file="$1"; shift

    local lastmod=
    if [ -f "$lastmod_file" ]; then
       lastmod=$(<lastmod_file)
    fi
    local response_code new_lastmod
    read -r response_code new_lastmod \
	 <<< "$(curl --silent \
	 	 --time-cond "$lastmod" \
	 	 --write-out '%{response_code} %header{last-modified}' \
		 --output "$file_out" "$url")"
    [ "$response_code" != 200 ] || echo "$new_lastmod" > "$lastmod_file"
    echo "$response_code"
}

sign() {
    local path="$1"; shift
    local a=("$@")
    local cert key k

    for k in "${!a[@]}"; do
	if [[ $((k % 2)) -eq 0 ]]; then
	    eval cert="${a[$k]}"
	elif [ -n "${a[$k]}" ]; then
	    eval key="${a[$k]}"
	    stmgr ospkg sign --cert "$cert" --key "$key" --ospkg "$path"
	    unset cert key
	fi
    done
    if [ -n "${cert-}" ]; then
	echo "skipping cert without key: $cert"
    fi
}

upload() {
    local path="$1"; shift
    local name; name="$(basename "$path")"

    echo "$name" | cat - "$path" | ssh "$host"
}

sign_and_upload() {
    local path="$1"; shift
    local host="$1"; shift
    local keys=("$@")

    local dir; dir="$(dirname "$path")"
    local fn; fn="$(basename "$path")"
    local cwd; cwd="$(pwd)"
    cd "$dir"
    unzip -qq "$fn"
    rm "$fn"
    mv stimages/build/*.{json,zip} .
    rm -rf stimages

    local zip
    for zip in *.zip; do
	fn="$(basename "$zip" .zip)"
	[ -f "$fn".json ] || continue # Skip if no .json
	sign "$fn".zip "${keys[@]}"
	upload "$fn".zip
	upload "$fn".json
    done

    cd "$cwd"
}

main() {
    trap 'rm -rf "$dir"' EXIT
    mkdir -p ~/.local/state/stsignd

    while true; do
	if [[ -f ~/.config/stsignd/config && -d ~/.config/stsignd/jobs ]]; then
	    for jobconf in ~/.config/stsignd/jobs/*.conf; do
		[ -n "${dir-}" ] && rm -rf "$dir"
		job="$(basename "$jobconf" .conf)"

		# shellcheck disable=SC2034
		read -r ulspec proj < "$jobconf" # $proj is used below when sourcing the config

		keys=()
		while read -r cert key; do
		    keys+=("$cert" "$key")
		done < ~/.config/stsignd/jobs/"$job".keys

		dir="$(mktemp -d /tmp/stsignd-XXXXXXXXXX)"

		# shellcheck source=/dev/null
		source ~/.config/stsignd/config # Substituting $proj and $job
		res="$(download "${download_url_template-localhost}" "$dir"/dl.zip ~/.local/state/stsignd/"$job".lastmod)"
		[ "$res" = 200 ] || continue

		sign_and_upload "$dir"/dl.zip "$ulspec" "${keys[@]}"
	    done
	fi
	sleep "${sleep_between_runs-5m}"
    done
}

main
